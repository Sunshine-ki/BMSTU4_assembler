section .text

global copy

; RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8 — R15 — 64-битные.

; Первые 6 аргументов (начиная слева) передаются в регистрах:
; RDI, RSI, RDX, RCX, R8, и R9.

; Т.е. в нашем случае в rdi будет string_result, в rsi string_user, а в rdx len.

;	 В rcx помещаем длину.
; MOVSB - Переслать байт из строки в строку.
; Записывает в ячейку по адресу RDI
; Байт из ячейки с адресом RSI.
; Именно поэтому первым аргументом мы передамем 
; Строку, в которую нужно записать результат 
; Т.к. она как раз и будет передана в регистре RDI.
; Второй аргумент, а именно строка, которую нужно скопировать, будет передан в регистр RSI
; Получается, что изначально аргументы передаются в нужные нам регистры (RDI и RSI).
; После пересылки данных оба регистра, RDI и RSI автоматически изменяются.
; В зависимости от флага DF.
; Команде MOVS предшествует префикс REP (REP - повторить следующую строковую операцию):
; Префикс заставляет строковую команду, которая следует за ним,
; Повторяться указанное в регистре счетчике RCX количество раз.

copy:
	mov rcx, rdx
	; Если равны выходим.
	cmp rsi, rdi
	je end

	; Команда LEA выполняет вычисление адреса второго операнда и записывание его в первый операнд
	lea rax, [rsi]
	add rax, rdx ; Теперь rax указывает на конец строки.
	; Сравниваем конец первой строки и начало второй строки.
	cmp rax, rdi 
	; Если s1 + len больше чем s2 
	; То копируем начиная с конца, чтобы не перезатереть данные.
	
	jg backward; Eсли больше  
	CLD ; Двигаемся вперед по строкам (См. файл asm, который вычисляет длину).

	rep movsb 
	jmp end

backward:
	add rsi, rdx
	add rdi, rdx
	dec rsi 
	dec rdi 
	std ; Двигаемся назад по строкам (DF = 1)
	rep movsb

end:
ret
